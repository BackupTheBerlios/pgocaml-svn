<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!-- Page generated by OCaml with Ocsigen.
See http://www.ocsigen.org and http://caml.inria.fr for information -->


<html>
  <head profile="http://www.w3.org/2005/11/profile">
    <title>Lambdoc document</title>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <link href="css/lambdoc.css" rel="stylesheet" media="all" title="Default" />
  </head>
  <body>
    <div class="doc_manuscript doc doc_valid">
      <h1 class="doc_title">A Brief Introduction to <span class="doc_caps">pg'ocaml</span><span class="doc_see">(<a class="doc_lnk" href="#doc:u:note:license">1</a>)</span>
      </h1>
      <h2 class="doc_title">Dario Teixeira
      </h2>
      <h2 class="doc_title">Version 2.0
      </h2>
      <h1 id="doc:a:1" class="doc_sec"><span class="doc_order">1</span><span>Introduction</span>
      </h1>
      <p class="doc_par"><span class="doc_caps">pg'ocaml</span>, by Richard W. M. Jones, provides an interface to <span class="doc_caps">postgresql</span> databases for <span class="doc_caps">ocaml</span> applications<span class="doc_cite">[<a class="doc_lnk" href="#doc:u:bib:pgocaml">1</a>,<a class="doc_lnk" href="#doc:u:bib:postgresql">2</a>,<a class="doc_lnk" href="#doc:u:bib:ocaml">3</a>]</span>. It uses <span class="doc_caps">camlp4</span> to extend the <span class="doc_caps">ocaml</span> syntax, enabling one to directly embed <span class="doc_caps">sql</span> statements inside the <span class="doc_caps">ocaml</span> code<span class="doc_cite">[<a class="doc_lnk" href="#doc:u:bib:camlp4">4</a>]</span>. Moreover, it uses the <i class="doc_emph">describe</i> feature of <span class="doc_caps">postgresql</span> to obtain type information about the database. This allows <span class="doc_caps">pg'ocaml</span> to check <b class="doc_bold">at compile-time</b> if the programme is indeed consistent with the database structure. This type-safe database access is the primary advantage that <span class="doc_caps">pg'ocaml</span> has over other <span class="doc_caps">postgresql</span> bindings for <span class="doc_caps">ocaml</span>.
      </p>
      <p class="doc_par">Unfortunately, <span class="doc_caps">pg'ocaml</span> is rather lacking on the documentation front. This document aims to fill that gap, by providing an overview of the capabilities of the library, usage examples, and solutions to potential pitfalls. Moreover, it also addresses the installation of <span class="doc_caps">pg'ocaml</span>, how to compile programmes that make use of the library, and the correspondence between <span class="doc_caps">postgresql</span> data types and their <span class="doc_caps">ocaml</span> counterparts.
      </p>
      <h1 id="doc:a:2" class="doc_sec"><span class="doc_order">2</span><span>Installation</span>
      </h1>
      <p class="doc_par">You are strongly advised to use <span class="doc_caps">ocamlfind</span> to aid in the management of <span class="doc_caps">ocaml</span> packages. The instructions on this document will therefore assume that you are using <span class="doc_caps">ocamlfind</span>, and that you will have <span class="doc_caps">pg'ocaml</span> installed in a manner consistent with it. Fortunately, the makefile included with the source code of <span class="doc_caps">pg'ocaml</span> already has provisions for adding <span class="doc_caps">pg'ocaml</span> to <span class="doc_caps">ocamlfind</span>'s repository. After you have built the <span class="doc_caps">pg'ocaml</span> library (typically with <tt class="doc_code">make all</tt>), simply run <tt class="doc_code">make findlib_install</tt> to perform the installation. This should create a <tt class="doc_code">pgocaml</tt> directory under the appropriate branch of <span class="doc_caps">ocamlfind</span>'s repository (normally under a directory named <tt class="doc_code">site-lib</tt> if you are using <span class="doc_caps">godi</span>). In this directory you will find the compiled <span class="doc_caps">pg'ocaml</span> libraries, plus the <tt class="doc_code">META</tt> file with special instructions for <span class="doc_caps">ocamlfind</span>.
      </p>
      <h1 id="doc:a:3" class="doc_sec"><span class="doc_order">3</span><span>Compilation of projects using <span class="doc_caps">pg'ocaml</span></span>
      </h1>
      <p class="doc_par"><a class="doc_lnk" href="#doc:u:out:makefile">Print.&nbsp;1</a> lists a basic makefile for compiling a project <i class="doc_emph">test</i> that makes use of <span class="doc_caps">pg'ocaml</span>. Note that the <span class="doc_caps">camlp4</span> syntax extension used by the <span class="doc_caps">pg'ocaml</span> can be handled in a fairly straightforward manner thanks to <span class="doc_caps">ocamlfind</span>. Note also that the sub-package <tt class="doc_code">pgocaml.syntax</tt> must be used during the compilation stage of code that makes use of the <span class="doc_caps">camlp4</span> syntax extensions. This sub-package is of course unnecessary during the linking stage.
      </p>
      <div id="doc:u:out:makefile" class="doc_wrapper doc_printout doc_float_center">
        <div class="doc_src_box doc_src_zebra doc_src_main">
          <pre class="doc_src_nums">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">01</code>
<code class="doc_src_line">02</code>
<code class="doc_src_line">03</code>
<code class="doc_src_line">04</code>
<code class="doc_src_line">05</code>
<code class="doc_src_line">06</code>
<code class="doc_src_line">07</code>
<code class="doc_src_line">08</code>
<code class="doc_src_line">09</code>
<code class="doc_src_line">10</code>
<code class="doc_src_line">11</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
          <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line"><span class="doc_src_Sym">PROJECT  :=</span> <span class="doc_src_Kwd">test</span></code>
<code class="doc_src_line"><span class="doc_src_Sym">LINK_PKG :=</span> pgocaml</code>
<code class="doc_src_line"><span class="doc_src_Sym">COMP_PKG :=</span> pgocaml<span class="doc_src_Sym">,</span>pgocaml.statements</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Sym">all:</span> <span class="doc_src_Var">$(PROJECT)</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Var">$(PROJECT)</span><span class="doc_src_Sym">:</span> <span class="doc_src_Var">$(PROJECT)</span>.cmo</code>
<code class="doc_src_line">        ocamlfind ocamlc -package <span class="doc_src_Var">$(LINK_PKG)</span> -linkpkg -o <span class="doc_src_Var">$@</span> <span class="doc_src_Var">$&lt;</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Var">$(PROJECT)</span>.cmo<span class="doc_src_Sym">:</span> <span class="doc_src_Var">$(PROJECT)</span>.ml</code>
<code class="doc_src_line">        ocamlfind ocamlc -package <span class="doc_src_Var">$(COMP_PKG)</span> -syntax camlp4o -c <span class="doc_src_Var">$&lt;</span></code>

<code class="doc_src_line doc_src_dummy"></code></pre>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Print.&nbsp;1:
            </h1>
            <p class="doc_caption_body">A simple Makefile to compile <span class="doc_caps">pg'ocaml</span> projects. Note that <span class="doc_caps">ocamlfind</span> must be installed in the system. In addition, the <span class="doc_caps">camlp4</span> preprocessor is invoked during the compilation stage.
            </p>
          </div>
        </div>
      </div>
      <h1 id="doc:a:4" class="doc_sec"><span class="doc_order">4</span><span>Basic usage</span>
      </h1>
      <p class="doc_par"><a class="doc_lnk" href="#doc:u:out:one">Print.&nbsp;2</a> lists a very simple programme that uses <span class="doc_caps">pg'ocaml</span>. In this section we shall dissect this programme function by function, thereby introducing the basic principles behind <span class="doc_caps">pg'ocaml</span>. Note that in order for the programme to compile and run, the <span class="doc_caps">postgresql</span> <i class="doc_emph">Postmaster</i><span class="doc_see">(<a class="doc_lnk" href="#doc:u:nt:postmaster">2</a>)</span> must be running on the local host, and there must be a database with the same name as your user's defined within the system (run <tt class="doc_code">createdb `whoami`</tt> if that is not the case). The reasons behind this should be made clear before this section is through.
      </p>
      <div id="doc:u:out:one" class="doc_wrapper doc_printout doc_float_center">
        <div class="doc_src_box doc_src_zebra doc_src_main">
          <pre class="doc_src_nums">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">01</code>
<code class="doc_src_line">02</code>
<code class="doc_src_line">03</code>
<code class="doc_src_line">04</code>
<code class="doc_src_line">05</code>
<code class="doc_src_line">06</code>
<code class="doc_src_line">07</code>
<code class="doc_src_line">08</code>
<code class="doc_src_line">09</code>
<code class="doc_src_line">10</code>
<code class="doc_src_line">11</code>
<code class="doc_src_line">12</code>
<code class="doc_src_line">13</code>
<code class="doc_src_line">14</code>
<code class="doc_src_line">15</code>
<code class="doc_src_line">16</code>
<code class="doc_src_line">17</code>
<code class="doc_src_line">18</code>
<code class="doc_src_line">19</code>
<code class="doc_src_line">20</code>
<code class="doc_src_line">21</code>
<code class="doc_src_line">22</code>
<code class="doc_src_line">23</code>
<code class="doc_src_line">24</code>
<code class="doc_src_line">25</code>
<code class="doc_src_line">26</code>
<code class="doc_src_line">27</code>
<code class="doc_src_line">28</code>
<code class="doc_src_line">29</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
          <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> create_table dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;execute&quot;</span> &quot;create temporary table users</code>
<code class="doc_src_line">      <span class="doc_src_Sym">(</span></code>
<code class="doc_src_line">      id          serial not null primary key<span class="doc_src_Sym">,</span></code>
<code class="doc_src_line">      name        text not null<span class="doc_src_Sym">,</span></code>
<code class="doc_src_line">      age         <span class="doc_src_Type">int</span> not null</code>
<code class="doc_src_line">      <span class="doc_src_Sym">)</span>&quot;</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> insert_user dbh name age <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> &quot;<span class="doc_src_Type">INSERT</span> <span class="doc_src_Type">INTO</span> users <span class="doc_src_Sym">(</span>name<span class="doc_src_Sym">,</span> age<span class="doc_src_Sym">)</span></code>
<code class="doc_src_line">                  <span class="doc_src_Type">VALUES</span> <span class="doc_src_Sym">(</span>$name<span class="doc_src_Sym">,</span> $age<span class="doc_src_Sym">)</span>&quot;</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> get_users dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;SELECT id, name, age FROM users&quot;</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> print_user <span class="doc_src_Sym">(</span>id<span class="doc_src_Sym">,</span> name<span class="doc_src_Sym">,</span> age<span class="doc_src_Sym">)</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Prep">Printf</span><span class="doc_src_Sym">.</span>printf <span class="doc_src_Str">&quot;Id: %ld  Name: %s  Age: %ld \n&quot;</span> id name age</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> dbh <span class="doc_src_Sym">=</span> <span class="doc_src_Prep">PGOCaml</span><span class="doc_src_Sym">.</span>connect <span class="doc_src_Sym">()</span> <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span> create_table dbh <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;John&quot;</span> 30l<span class="doc_src_Sym">;</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;Mary&quot;</span> 40l<span class="doc_src_Sym">;</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;Mark&quot;</span> 42l <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Prep">List</span><span class="doc_src_Sym">.</span>iter print_user <span class="doc_src_Sym">(</span>get_users dbh<span class="doc_src_Sym">)</span></code>

<code class="doc_src_line doc_src_dummy"></code></pre>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Print.&nbsp;2:
            </h1>
            <p class="doc_caption_body">A simple programme using <span class="doc_caps">pg'ocaml</span>. Note the syntax extension enabling the embedding of <span class="doc_caps">sql</span> statements inside <span class="doc_caps">ocaml</span> code.
            </p>
          </div>
        </div>
      </div>
      <p class="doc_par">From a bird's eye perspective, what stands out immediately is the embedding of <span class="doc_caps">sql</span> statements inside the <span class="doc_caps">ocaml</span> code. <span class="doc_caps">pg'ocaml</span> can deal with pretty much all valid <span class="doc_caps">sql</span> statements, including sub-selects. Though not quite as conspicuous, a more careful look at the code will show that <span class="doc_caps">pg'ocaml</span> must somehow be extending the type-safety of <span class="doc_caps">ocaml</span> to the embedded statements. Note that the <tt class="doc_code">users</tt> table is declared to have three columns, respectively of <span class="doc_caps">sql</span> types <tt class="doc_code">serial</tt>, <tt class="doc_code">text</tt>, and <tt class="doc_code">int</tt> (all of them <tt class="doc_code">not null</tt>). If one were to run <tt class="doc_code">ocamlc -i</tt> on this code, the signature of the <tt class="doc_code">print_user</tt> function would equal <tt class="doc_code">val print_user : int32 * string * int32 -&gt; unit</tt>, indicating that the system was able to infer the correct <span class="doc_caps">ocaml</span> types that correspond to the <span class="doc_caps">postgresql</span> types declared in the embedded statements (see <a class="doc_lnk" href="#doc:u:sec:types">Section&nbsp;5</a> for a more thorough description of the correspondence between <span class="doc_caps">postgresql</span> and <span class="doc_caps">ocaml</span> data types).
      </p>
      <p class="doc_par">As for the syntax extension, it takes the form of the macro <tt class="doc_code">PGSQL</tt>, followed by the database handle between parentheses, an optional sequence of strings with the statement flags, and a final, mandatory string with the actual <span class="doc_caps">sql</span> statement. You can see the extension in use in functions <tt class="doc_code">create_table</tt>, <tt class="doc_code">insert_user</tt>, and <tt class="doc_code">get_users</tt>.
      </p>
      <h2 id="doc:u:sec:flags" class="doc_sec"><span class="doc_order">4.1</span><span>Statement flags and environment variables</span>
      </h2>
      <p class="doc_par">The sage reader will have come to the conclusion that in order for the compiler to verify the correct match between the database structure and the types used in the programme, <span class="doc_caps">pg'ocaml</span> must have access to the database <b class="doc_bold">at compile-time</b>. That is indeed true. Moreover, it follows that there must be at least one mechanism that allows the programmer to inform <span class="doc_caps">pg'ocaml</span> where the relevant <span class="doc_caps">postgresql</span> <i class="doc_emph">Postmaster</i> is located, and how the target database should be accessed. In fact, <span class="doc_caps">pg'ocaml</span> provides not one, but two different and alternative mechanisms for this purpose: environment variables, and statement flags.
      </p>
      <p class="doc_par">Environment variables are set via the normal mechanism available in the operating system. Due to their global nature, they apply to <b class="doc_bold">all</b> <span class="doc_caps">pg'ocaml</span> statements in the programme. Moreover, they can be used both at compile-time and runtime. As for statement flags, they take the form of string constants placed before the <span class="doc_caps">sql</span> statement proper. They are therefore valid only for that statement. In the example shown in <a class="doc_lnk" href="#doc:u:out:one">Print.&nbsp;2</a>, only one statement flag is used: the <tt class="doc_code">&quot;execute&quot;</tt> placed before the <span class="doc_caps">sql</span> statement in function <tt class="doc_code">create_table</tt>.
      </p>
      <p class="doc_par"><a class="doc_lnk" href="#doc:u:tab:flags">Tab.&nbsp;1</a> lists all statement flags and associated environment variables. A statement flag will override the corresponding environment variable, and lacking both, the built-in defaults are used. You can now understand why the example in <a class="doc_lnk" href="#doc:u:out:one">Print.&nbsp;2</a> requires that a database with your user name exists in the local host: since we have not declared neither host, nor user, nor database, the default is to use the local machine, your user name, and a database named after the user, respectively.
      </p>
      <div id="doc:u:tab:flags" class="doc_wrapper doc_table doc_float_center">
        <div class="doc_tab">
          <div class="doc_tab_aux">
            <table>
              <thead class="doc_tgroup">
                <tr>
                  <td class="doc_cell_l">Statement flag
                    <br />(Environment variable)
                  </td>
                  <td class="doc_cell_l"><b class="doc_bold">Observations</b>
                  </td>
                </tr>
              </thead>
              <tbody class="doc_tgroup">
                <tr>
                  <td class="doc_cell_l">host=...
                    <br />(pghost) 
                  </td>
                  <td class="doc_cell_l">If the host is not specified, the connection will default to the localhost, using a <span class="doc_caps">unix</span> domain socket for communication.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">port=...
                    <br />(pgport) 
                  </td>
                  <td class="doc_cell_l">If the port number is not specified, the default is 5432. Note that the port number is only used if the host is specified.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">user=...
                    <br />(pguser) 
                  </td>
                  <td class="doc_cell_l">If no user name is specified, the default is to use the current <span class="doc_caps">unix</span> user name. If the latter is also unavailable, <tt class="doc_code">postgres</tt> is tried.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">password=...
                    <br />(pgpassword) 
                  </td>
                  <td class="doc_cell_l">The password used to authenticate the user, if the <span class="doc_caps">postgresql</span> configuration so requires.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">database=...
                    <br />(pgdatabase) 
                  </td>
                  <td class="doc_cell_l">The name of the database we wish to connect to. If not specified, a database with the same name as the user is tried.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">unix_domain_socket_dir=...
                    <br />(unix_domain_socket_dir) 
                  </td>
                  <td class="doc_cell_l">The directory where the <span class="doc_caps">unix</span> domain socket can be located. In a <span class="doc_caps">debian</span> system, for instance, this directory is typically <tt class="doc_code">/var/run/postgresql/</tt>.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">execute
                    <br />(n/a) 
                  </td>
                  <td class="doc_cell_l">Tells <span class="doc_caps">pg'ocaml</span> that the statement should be executed immediately (at compile-time). This flag only makes sense on a statement by statement basis, and therefore has no equivalent environment variable.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">nullable-results
                    <br />(n/a) 
                  </td>
                  <td class="doc_cell_l">Disables the <i class="doc_emph">nullability</i> heuristics for all columns. For details consult the <tt class="doc_code">BUGS.txt</tt> file included with <span class="doc_caps">pg'ocaml</span>.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Tab.&nbsp;1:
            </h1>
            <p class="doc_caption_body">Statement flags and environment variables. Note that statement flags are only valid at compile-time and on a statement by statement basis. Environment variables, on the other hand, are valid both at compile-time and runtime; moreover, they apply globally, to all statements.
            </p>
          </div>
        </div>
      </div>
      <h2 id="doc:u:sec:connect" class="doc_sec"><span class="doc_order">4.2</span><span>The connection handle</span>
      </h2>
      <p class="doc_par">At runtime, before any <span class="doc_caps">sql</span> statements can be issued, you must create a connection handler to the <span class="doc_caps">postgresql</span> database. This handler is created by the <tt class="doc_code">PGOCaml.connect</tt> function, whose signature is shown in <a class="doc_lnk" href="#doc:u:out:connect">Print.&nbsp;3</a>. Note that the optional parameters for this function mirror those available via the environment variables. In the code shown in <a class="doc_lnk" href="#doc:u:out:one">Print.&nbsp;2</a>, the connection handle <tt class="doc_code">dbh</tt> is created by the first statement of the top-level anonymous let-binding.
      </p>
      <div id="doc:u:out:connect" class="doc_wrapper doc_printout doc_float_center">
        <div class="doc_src_box doc_src_zebra doc_src_main">
          <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">val connect :</code>
<code class="doc_src_line">        ?host:string -&gt;</code>
<code class="doc_src_line">        ?port:int -&gt;</code>
<code class="doc_src_line">        ?user:string -&gt;</code>
<code class="doc_src_line">        ?password:string -&gt;</code>
<code class="doc_src_line">        ?database:string -&gt;</code>
<code class="doc_src_line">        ?unix_domain_socket_dir:string -&gt;</code>
<code class="doc_src_line">        unit -&gt; 'a t</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Print.&nbsp;3:
            </h1>
            <p class="doc_caption_body">The signature of function <tt class="doc_code">PGOCaml.connect</tt>, used to create a database connection handle.
            </p>
          </div>
        </div>
      </div>
      <p class="doc_par">At this point, the reader may be wondering if there is not redundancy between the parameters of the <tt class="doc_code">connect</tt> function and the already discussed statement flags and environment variables. Partly yes, though there are still good reasons why <tt class="doc_code">connect</tt> accepts these parameters as well. First, bear in mind that the statement flags are valid only at compile-time, while the parameters to <tt class="doc_code">connect</tt> are used only at runtime. Second, though environment variables can be used both at compile and runtime, they require an action by the user to set them up. By passing the connection parameters directly in the <tt class="doc_code">connect</tt> function, the programme is able to run correctly even if the user forgets to set the environment variables. Moreover, the parameters to <tt class="doc_code">connect</tt> trump environment variable definitions.
      </p>
      <h2 id="doc:u:sec:param" class="doc_sec"><span class="doc_order">4.3</span><span>Parameters and return values of <span class="doc_caps">sql</span> statements</span>
      </h2>
      <p class="doc_par">As shown in function <tt class="doc_code">insert_user</tt>, the basic notation for passing an <span class="doc_caps">ocaml</span> value to an <span class="doc_caps">sql</span> statement is to simply prefix the name of the value with the dollar sign <tt class="doc_code">$</tt> (optional and array types require a different notation, discussed in <a class="doc_lnk" href="#doc:u:sec:optional">Section&nbsp;5.1</a>.
      </p>
      <p class="doc_par">As for the return type of the embedded <span class="doc_caps">sql</span> statements, they match fairly closely the natural types one would expect. Statements that return no data (such as the <tt class="doc_code">INSERT</tt> statement in function <tt class="doc_code">insert_user</tt>) have type <tt class="doc_code">unit</tt>. Likewise, <tt class="doc_code">SELECT</tt> statements (such as the one in function <tt class="doc_code">get_users</tt>) will typically return a list of tuples.
      </p>
      <p class="doc_par">If in doubt about the actual return type of a more complex statement (such as one involving <span class="doc_caps">sql</span> aggregate functions), then <tt class="doc_code">ocamlc -i</tt> is your friend. Consider, for example, that we were to add to the programme the function <tt class="doc_code">get_aggregates</tt> listed in <a class="doc_lnk" href="#doc:u:out:aggregates">Print.&nbsp;4</a>. It is far from obvious what the actual signature of this function is. Thankfully, the figure shows also the signature produced by <tt class="doc_code">ocamlc -i</tt>, telling us that the function returns a list (typically composed of a single element) of tuples. The tuples are formed by two optional types: an <tt class="doc_code">int64</tt> corresponding to the number of rows in the table<span class="doc_see">(<a class="doc_lnk" href="#doc:u:nt:rows">3</a>)</span>, and a float corresponding to the average of the user ages.
      </p>
      <div id="doc:u:out:aggregates" class="doc_wrapper doc_printout doc_float_center">
        <div class="doc_src_box doc_src_zebra doc_src_main">
          <pre class="doc_src_nums">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">1</code>
<code class="doc_src_line">2</code>
<code class="doc_src_line">3</code>
<code class="doc_src_line">4</code>
<code class="doc_src_line">5</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
          <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> get_aggregates dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">    <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;SELECT COUNT (id), AVG (age) FROM users&quot;</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">val</span> get_aggregates <span class="doc_src_Sym">:</span></code>
<code class="doc_src_line">    <span class="doc_src_Sym">(</span><span class="doc_src_Type">string</span><span class="doc_src_Sym">,</span> <span class="doc_src_Type">bool</span><span class="doc_src_Sym">)</span> <span class="doc_src_Prep">Hashtbl</span><span class="doc_src_Sym">.</span>t <span class="doc_src_Prep">PGOCaml</span><span class="doc_src_Sym">.</span>t <span class="doc_src_Sym">-&gt;</span> <span class="doc_src_Sym">(</span><span class="doc_src_Type">int64</span> <span class="doc_src_Type">option</span> <span class="doc_src_Sym">*</span> <span class="doc_src_Type">float</span> <span class="doc_src_Type">option</span><span class="doc_src_Sym">)</span> <span class="doc_src_Type">list</span></code>

<code class="doc_src_line doc_src_dummy"></code></pre>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Print.&nbsp;4:
            </h1>
            <p class="doc_caption_body">A new function <tt class="doc_code">get_aggregates</tt> that returns the number of rows in the <tt class="doc_code">users</tt> table and the average of the <tt class="doc_code">age</tt> column. Note that the signature of this function is far from obvious, so <tt class="doc_code">ocamlc -i</tt> can be of help.
            </p>
          </div>
        </div>
      </div>
      <h1 id="doc:u:sec:types" class="doc_sec"><span class="doc_order">5</span><span>Data types</span>
      </h1>
      <p class="doc_par">The translation between <span class="doc_caps">postgresql</span> and <span class="doc_caps">ocaml</span> types is not as straightforward as one might think. Consider for example that due to requirements of the garbage collector, the <tt class="doc_code">int</tt> type in <span class="doc_caps">ocaml</span> is actually 31 bits long, instead of the 32 bits integers commonly found in other languages and in <span class="doc_caps">postgresql</span>'s own <tt class="doc_code">int</tt> type.
      </p>
      <p class="doc_par"><span class="doc_caps">pg'ocaml</span> chooses safety and correctness over potential performance gains. Therefore, <span class="doc_caps">postgresql</span>'s <tt class="doc_code">int</tt> type is mapped into <span class="doc_caps">ocaml</span>'s <tt class="doc_code">int32</tt>. <a class="doc_lnk" href="#doc:u:tab:types">Tab.&nbsp;2</a> lists the correspondence between all the <span class="doc_caps">postgresql</span> types currently supported by <span class="doc_caps">pg'ocaml</span> and their <span class="doc_caps">ocaml</span> counterparts. Note in particular that all character types are mapped onto <span class="doc_caps">ocaml</span>'s <tt class="doc_code">string</tt>, and that thanks to the facilities offered by the <span class="doc_caps">calendar</span> library<span class="doc_cite">[<a class="doc_lnk" href="#doc:u:bib:calendar">5</a>]</span>, it is also possible to do a type-safe and semantically correct mapping of the time and date types.
      </p>
      <div id="doc:u:tab:types" class="doc_wrapper doc_table doc_float_center">
        <div class="doc_tab">
          <div class="doc_tab_aux">
            <table>
              <thead class="doc_tgroup">
                <tr>
                  <td class="doc_cell_l"><span class="doc_caps">postgresql</span>
                  </td>
                  <td class="doc_cell_l"><span class="doc_caps">ocaml</span>
                  </td>
                </tr>
              </thead>
              <tbody class="doc_tgroup">
                <tr>
                  <td class="doc_cell_c doc_uline" colspan="2">Numeric types
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">int2, smallint
                  </td>
                  <td class="doc_cell_l">PGOCaml.int16 <tt class="doc_code">PGOCaml.int16</tt> is defined as <tt class="doc_code">int</tt>.
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">int4, int, integer
                  </td>
                  <td class="doc_cell_l">int32
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">serial
                  </td>
                  <td class="doc_cell_l">int32
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">int8, bigint
                  </td>
                  <td class="doc_cell_l">int64
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">decimal, numeric
                  </td>
                  <td class="doc_cell_l">float
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">float8, float, double precision
                  </td>
                  <td class="doc_cell_l">float
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">float4, real
                  </td>
                  <td class="doc_cell_l">float
                  </td>
                </tr>
              </tbody>
              <tbody class="doc_tgroup">
                <tr>
                  <td class="doc_cell_c doc_uline" colspan="2">Character types
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">char, character
                  </td>
                  <td class="doc_cell_l">string
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">varchar, character varying
                  </td>
                  <td class="doc_cell_l">string
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">text
                  </td>
                  <td class="doc_cell_l">string
                  </td>
                </tr>
              </tbody>
              <tbody class="doc_tgroup">
                <tr>
                  <td class="doc_cell_c doc_uline" colspan="2">Time and date types
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">date
                  </td>
                  <td class="doc_cell_l">Date.t
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">interval
                  </td>
                  <td class="doc_cell_l">Calendar.Period.t
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">time
                  </td>
                  <td class="doc_cell_l">Time.t
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">timestamp
                  </td>
                  <td class="doc_cell_l">Calendar.t
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">timestamptz
                  </td>
                  <td class="doc_cell_l">PGOCaml.timestamptz <tt class="doc_code">PGOCaml.timestamptz</tt> is defined as <tt class="doc_code">Calendar.t * Time_Zone.t</tt>.
                  </td>
                </tr>
              </tbody>
              <tbody class="doc_tgroup">
                <tr>
                  <td class="doc_cell_c doc_uline" colspan="2">Blob types
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">bytea
                  </td>
                  <td class="doc_cell_l">PGOCaml.bytea <tt class="doc_code">PGOCaml.bytea</tt> is defined as <tt class="doc_code">string</tt>.
                  </td>
                </tr>
              </tbody>
              <tbody class="doc_tgroup">
                <tr>
                  <td class="doc_cell_c doc_uline" colspan="2">Logical types
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">bool, boolean
                  </td>
                  <td class="doc_cell_l">bool
                  </td>
                </tr>
              </tbody>
              <tbody class="doc_tgroup">
                <tr>
                  <td class="doc_cell_c doc_uline" colspan="2">Array types
                  </td>
                </tr>
                <tr>
                  <td class="doc_cell_l">int[]
                  </td>
                  <td class="doc_cell_l">PGOCaml.int32_array <tt class="doc_code">PGOCaml.int32_array</tt> is defined as <tt class="doc_code">int32 array</tt>.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Tab.&nbsp;2:
            </h1>
            <p class="doc_caption_body">Correspondence between <span class="doc_caps">postgresql</span> types and their <span class="doc_caps">ocaml</span> counterparts. Note that most integer types are mapped onto either <tt class="doc_code">int32</tt> or <tt class="doc_code">int64</tt>, to avoid overflowing the 31 bits of <span class="doc_caps">ocaml</span>'s native <tt class="doc_code">int</tt> type. As for character types, they are all mapped onto <span class="doc_caps">ocaml</span> <tt class="doc_code">string</tt>. At last, note that temporal types are mapped onto the facilities offered by the <span class="doc_caps">calendar</span> library.
            </p>
          </div>
        </div>
      </div>
      <h2 id="doc:u:sec:optional" class="doc_sec"><span class="doc_order">5.1</span><span>Handling optional types</span>
      </h2>
      <p class="doc_par"><span class="doc_caps">sql</span> features the possibility of declaring certain columns as <tt class="doc_code">NULL</tt> (this is in fact the default if the column is not explicitly declared <tt class="doc_code">NOT NULL</tt>). These <tt class="doc_code">NULL</tt> values in <span class="doc_caps">sql</span> represent essentially the same concept as the <tt class="doc_code">None</tt> in <span class="doc_caps">ocaml</span>'s optional types. Therefore, it should not come as a surprise that <span class="doc_caps">pg'ocaml</span> uses optional types to represent <span class="doc_caps">sql</span> columns that accept <tt class="doc_code">NULL</tt> values.
      </p>
      <div id="doc:u:out:two" class="doc_wrapper doc_printout doc_float_center">
        <div class="doc_src_box doc_src_zebra doc_src_main">
          <pre class="doc_src_nums">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">01</code>
<code class="doc_src_line">02</code>
<code class="doc_src_line">03</code>
<code class="doc_src_line">04</code>
<code class="doc_src_line">05</code>
<code class="doc_src_line">06</code>
<code class="doc_src_line">07</code>
<code class="doc_src_line">08</code>
<code class="doc_src_line">09</code>
<code class="doc_src_line">10</code>
<code class="doc_src_line">11</code>
<code class="doc_src_line">12</code>
<code class="doc_src_line">13</code>
<code class="doc_src_line">14</code>
<code class="doc_src_line">15</code>
<code class="doc_src_line">16</code>
<code class="doc_src_line">17</code>
<code class="doc_src_line">18</code>
<code class="doc_src_line">19</code>
<code class="doc_src_line">20</code>
<code class="doc_src_line">21</code>
<code class="doc_src_line">22</code>
<code class="doc_src_line">23</code>
<code class="doc_src_line">24</code>
<code class="doc_src_line">25</code>
<code class="doc_src_line">26</code>
<code class="doc_src_line">27</code>
<code class="doc_src_line">28</code>
<code class="doc_src_line">29</code>
<code class="doc_src_line">30</code>
<code class="doc_src_line">31</code>
<code class="doc_src_line">32</code>
<code class="doc_src_line">33</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
          <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> create_table dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;execute&quot;</span> &quot;create temporary table users</code>
<code class="doc_src_line">      <span class="doc_src_Sym">(</span></code>
<code class="doc_src_line">      id          serial not null primary key<span class="doc_src_Sym">,</span></code>
<code class="doc_src_line">      name        text not null<span class="doc_src_Sym">,</span></code>
<code class="doc_src_line">      age         <span class="doc_src_Type">int</span></code>
<code class="doc_src_line">      <span class="doc_src_Sym">)</span>&quot;</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> insert_user dbh name age <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> &quot;<span class="doc_src_Type">INSERT</span> <span class="doc_src_Type">INTO</span> users <span class="doc_src_Sym">(</span>name<span class="doc_src_Sym">,</span> age<span class="doc_src_Sym">)</span></code>
<code class="doc_src_line">                  <span class="doc_src_Type">VALUES</span> <span class="doc_src_Sym">(</span>$name<span class="doc_src_Sym">,</span> $<span class="doc_src_Sym">?</span>age<span class="doc_src_Sym">)</span>&quot;</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> get_users dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;SELECT id, name, age FROM users&quot;</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> print_user <span class="doc_src_Sym">(</span>id<span class="doc_src_Sym">,</span> name<span class="doc_src_Sym">,</span> age<span class="doc_src_Sym">)</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> age_str <span class="doc_src_Sym">=</span> <span class="doc_src_Kwd">match</span> age <span class="doc_src_Kwd">with</span></code>
<code class="doc_src_line">            <span class="doc_src_Sym">|</span> <span class="doc_src_Type">Some</span> number     <span class="doc_src_Sym">-&gt;</span> <span class="doc_src_Prep">Int32</span><span class="doc_src_Sym">.</span>to_string number</code>
<code class="doc_src_line">            <span class="doc_src_Sym">|</span> <span class="doc_src_Type">None</span>            <span class="doc_src_Sym">-&gt;</span> <span class="doc_src_Str">&quot;(no age)&quot;</span></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">in</span></code>
<code class="doc_src_line">      <span class="doc_src_Prep">Printf</span><span class="doc_src_Sym">.</span>printf <span class="doc_src_Str">&quot;Id: %ld  Name: %s  Age: %s \n&quot;</span> id name age_str</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> _ <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> dbh <span class="doc_src_Sym">=</span> <span class="doc_src_Prep">PGOCaml</span><span class="doc_src_Sym">.</span>connect <span class="doc_src_Sym">()</span> <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span> create_table dbh <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;John&quot;</span> <span class="doc_src_Sym">(</span><span class="doc_src_Type">Some</span> 30_l<span class="doc_src_Sym">);</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;Mary&quot;</span> <span class="doc_src_Sym">(</span><span class="doc_src_Type">Some</span> 40_l<span class="doc_src_Sym">);</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;Mark&quot;</span> <span class="doc_src_Type">None</span> <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Prep">List</span><span class="doc_src_Sym">.</span>iter print_user <span class="doc_src_Sym">(</span>get_users dbh<span class="doc_src_Sym">)</span></code>

<code class="doc_src_line doc_src_dummy"></code></pre>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Print.&nbsp;5:
            </h1>
            <p class="doc_caption_body">An extended example, making use of optional types. Note that because the <span class="doc_caps">postgresql</span> type of column <tt class="doc_code">age</tt> now accepts <tt class="doc_code">NULL</tt> values, its corresponding <span class="doc_caps">ocaml</span> type has been changed to <tt class="doc_code">int32 option</tt>.
            </p>
          </div>
        </div>
      </div>
      <p class="doc_par"><a class="doc_lnk" href="#doc:u:out:two">Print.&nbsp;5</a> lists a modified version of our original programme. Note that we have made <tt class="doc_code">NULL</tt> values acceptable for the column <tt class="doc_code">age</tt>. As a consequence, the associated <span class="doc_caps">ocaml</span> type is now <tt class="doc_code">int32 option</tt>. You will notice that function <tt class="doc_code">print_user</tt> has some extra code to handle for the possibility of no age being defined. Note also that when referencing an optional type inside an embedded statement, the notation <tt class="doc_code">$?</tt> should be used instead of the plain <tt class="doc_code">$</tt>.
      </p>
      <h2 id="doc:a:5" class="doc_sec"><span class="doc_order">5.2</span><span>Array types and list expressions</span>
      </h2>
      <p class="doc_par"><a class="doc_lnk" href="#doc:u:out:three">Print.&nbsp;6</a> lists further modifications to our original programme. Besides the changes incorporated in <a class="doc_lnk" href="#doc:u:out:two">Print.&nbsp;5</a>, the reader will notice that we added a new column to the table, of type <tt class="doc_code">int[]</tt>. <span class="doc_caps">postgresql</span> supports arrays are column types, and <span class="doc_caps">pg'ocaml</span> also has limited support for them. Note also that we added two new functions, <tt class="doc_code">get_2_users</tt> and <tt class="doc_code">get_n_users</tt>, both using list expressions.
      </p>
      <div id="doc:u:out:three" class="doc_wrapper doc_printout doc_float_center">
        <div class="doc_src_box doc_src_zebra doc_src_main">
          <pre class="doc_src_nums">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">01</code>
<code class="doc_src_line">02</code>
<code class="doc_src_line">03</code>
<code class="doc_src_line">04</code>
<code class="doc_src_line">05</code>
<code class="doc_src_line">06</code>
<code class="doc_src_line">07</code>
<code class="doc_src_line">08</code>
<code class="doc_src_line">09</code>
<code class="doc_src_line">10</code>
<code class="doc_src_line">11</code>
<code class="doc_src_line">12</code>
<code class="doc_src_line">13</code>
<code class="doc_src_line">14</code>
<code class="doc_src_line">15</code>
<code class="doc_src_line">16</code>
<code class="doc_src_line">17</code>
<code class="doc_src_line">18</code>
<code class="doc_src_line">19</code>
<code class="doc_src_line">20</code>
<code class="doc_src_line">21</code>
<code class="doc_src_line">22</code>
<code class="doc_src_line">23</code>
<code class="doc_src_line">24</code>
<code class="doc_src_line">25</code>
<code class="doc_src_line">26</code>
<code class="doc_src_line">27</code>
<code class="doc_src_line">28</code>
<code class="doc_src_line">29</code>
<code class="doc_src_line">30</code>
<code class="doc_src_line">31</code>
<code class="doc_src_line">32</code>
<code class="doc_src_line">33</code>
<code class="doc_src_line">34</code>
<code class="doc_src_line">35</code>
<code class="doc_src_line">36</code>
<code class="doc_src_line">37</code>
<code class="doc_src_line">38</code>
<code class="doc_src_line">39</code>
<code class="doc_src_line">40</code>
<code class="doc_src_line">41</code>
<code class="doc_src_line">42</code>
<code class="doc_src_line">43</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
          <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">et create_table dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;execute&quot;</span> &quot;create temporary table users</code>
<code class="doc_src_line">      <span class="doc_src_Sym">(</span></code>
<code class="doc_src_line">      id          serial not null primary key<span class="doc_src_Sym">,</span></code>
<code class="doc_src_line">      name        text not null<span class="doc_src_Sym">,</span></code>
<code class="doc_src_line">      age         <span class="doc_src_Type">int</span><span class="doc_src_Sym">,</span></code>
<code class="doc_src_line">      votes       <span class="doc_src_Type">int</span><span class="doc_src_Sym">[]</span></code>
<code class="doc_src_line">      <span class="doc_src_Sym">)</span>&quot;</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> insert_user dbh name age votes <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> &quot;<span class="doc_src_Type">INSERT</span> <span class="doc_src_Type">INTO</span> users <span class="doc_src_Sym">(</span>name<span class="doc_src_Sym">,</span> age<span class="doc_src_Sym">,</span> votes<span class="doc_src_Sym">)</span></code>
<code class="doc_src_line">                  <span class="doc_src_Type">VALUES</span> <span class="doc_src_Sym">(</span>$name<span class="doc_src_Sym">,</span> $<span class="doc_src_Sym">?</span>age<span class="doc_src_Sym">,</span> $votes<span class="doc_src_Sym">)</span>&quot;</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> get_users dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;SELECT id, name, age FROM users&quot;</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> get_2_users dbh <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;SELECT id, name, age FROM users WHERE id IN (1, 2)&quot;</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> get_n_users dbh user_ids <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;SELECT id, name, age FROM users WHERE id IN $@user_ids&quot;</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> print_user <span class="doc_src_Sym">(</span>id<span class="doc_src_Sym">,</span> name<span class="doc_src_Sym">,</span> age<span class="doc_src_Sym">)</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> age_str <span class="doc_src_Sym">=</span> <span class="doc_src_Kwd">match</span> age <span class="doc_src_Kwd">with</span></code>
<code class="doc_src_line">            <span class="doc_src_Sym">|</span> <span class="doc_src_Type">Some</span> number     <span class="doc_src_Sym">-&gt;</span> <span class="doc_src_Prep">Int32</span><span class="doc_src_Sym">.</span>to_string number</code>
<code class="doc_src_line">            <span class="doc_src_Sym">|</span> <span class="doc_src_Type">None</span>            <span class="doc_src_Sym">-&gt;</span> <span class="doc_src_Str">&quot;(no age)&quot;</span></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">in</span></code>
<code class="doc_src_line">      <span class="doc_src_Prep">Printf</span><span class="doc_src_Sym">.</span>printf <span class="doc_src_Str">&quot;Id: %ld  Name: %s  Age: %s \n&quot;</span></code>
<code class="doc_src_line">            id name age_str</code>

<code class="doc_src_line"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> dbh <span class="doc_src_Sym">=</span> <span class="doc_src_Prep">PGOCaml</span><span class="doc_src_Sym">.</span>connect <span class="doc_src_Sym">()</span> <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span> create_table dbh <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Kwd">let</span> <span class="doc_src_Sym">()</span> <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;John&quot;</span> <span class="doc_src_Sym">(</span><span class="doc_src_Type">Some</span> 30_l<span class="doc_src_Sym">)</span> <span class="doc_src_Sym">[|</span> 10_l<span class="doc_src_Sym">;</span> 15_l <span class="doc_src_Sym">|];</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;Mary&quot;</span> <span class="doc_src_Sym">(</span><span class="doc_src_Type">Some</span> 40_l<span class="doc_src_Sym">)</span> <span class="doc_src_Sym">[|</span> 16_l <span class="doc_src_Sym">|];</span></code>
<code class="doc_src_line">            insert_user dbh <span class="doc_src_Str">&quot;Mark&quot;</span> <span class="doc_src_Type">None</span> <span class="doc_src_Sym">[|</span> <span class="doc_src_Sym">|]</span> <span class="doc_src_Kwd">in</span></code>

<code class="doc_src_line"></code>
<code class="doc_src_line">      <span class="doc_src_Prep">List</span><span class="doc_src_Sym">.</span>iter print_user <span class="doc_src_Sym">(</span>get_users dbh<span class="doc_src_Sym">);</span></code>
<code class="doc_src_line">      <span class="doc_src_Prep">List</span><span class="doc_src_Sym">.</span>iter print_user <span class="doc_src_Sym">(</span>get_2_users dbh<span class="doc_src_Sym">);</span></code>
<code class="doc_src_line">      <span class="doc_src_Prep">List</span><span class="doc_src_Sym">.</span>iter print_user <span class="doc_src_Sym">(</span>get_n_users dbh <span class="doc_src_Sym">[</span>2_l<span class="doc_src_Sym">;</span> 3_l<span class="doc_src_Sym">])</span></code>

<code class="doc_src_line doc_src_dummy"></code></pre>
        </div>
        <div class="doc_caption doc_caption_long">
          <div class="doc_caption_aux">
            <h1 class="doc_caption_head">Print.&nbsp;6:
            </h1>
            <p class="doc_caption_body">An example using array types and list expressions. While the former are referred to just like any other <span class="doc_caps">postgresql</span> type, the latter require the use of the special <tt class="doc_code">$@</tt> notation if used programatically, as illustrated by function <tt class="doc_code">get_n_users</tt> (note that this function will cause a runtime exception if the list <tt class="doc_code">user_ids</tt> happens to be empty; a workaround is shown in <a class="doc_lnk" href="#doc:u:out:emptylist">Print.&nbsp;7</a>).
            </p>
          </div>
        </div>
      </div>
      <p class="doc_par">It is important that array types and list expressions are not confused. The former are used in <span class="doc_caps">pg'ocaml</span> just like any other type; note that we use the basic <tt class="doc_code">$</tt> notation to refer to column <tt class="doc_code">votes</tt>. As for list expressions (the <tt class="doc_code">(1, 2)</tt> used in function <tt class="doc_code">get_2_users</tt>, for example) they require a special notation if they are created programatically. Function <tt class="doc_code">get_n_users</tt> illustrates this aspect: note the use of the <tt class="doc_code">$@</tt> notation.
      </p>
      <p class="doc_par">While certainly useful, the programatic use of list expressions has a number of caveats that the user should be aware of. These stem from shortcomings in the <span class="doc_caps">sql</span> standard, bugs in older versions (pre 8.x) of <span class="doc_caps">postgresql</span>, and limitations inherent to the way <span class="doc_caps">pg'ocaml</span> prepares <span class="doc_caps">sql</span> statements. The user is strongly advised to take heed of these warnings:
      </p>
      <ol class="doc_enumerate doc_style_decimal">
        <li class="doc_item">
          <p class="doc_par">Due to an unfortunate lack of foresight, the <span class="doc_caps">sql</span> standard does not accept empty list expressions. Therefore, if we were to replace the <tt class="doc_code">(1, 2)</tt> list in function <tt class="doc_code">get_2_users</tt> with the empty list <tt class="doc_code">()</tt>, compilation would fail with a syntax error. More worryingly, the programatic use of list expressions (as exemplified by function <tt class="doc_code">get_n_users</tt>) brings forth the very real danger of an empty list being passed to an <span class="doc_caps">sql</span> statement, causing a syntax error complaint from the database server and consequent exception at runtime. You are therefore strongly advised to guard against this possibility by checking beforehand if the list is empty. A revised, correct version of function <tt class="doc_code">get_n_users</tt> is shown in <a class="doc_lnk" href="#doc:u:out:emptylist">Print.&nbsp;7</a>.
          </p>
          <div id="doc:u:out:emptylist" class="doc_wrapper doc_printout doc_float_center">
            <div class="doc_src_box doc_src_zebra doc_src_main">
              <pre class="doc_src_nums">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">1</code>
<code class="doc_src_line">2</code>
<code class="doc_src_line">3</code>
<code class="doc_src_line">4</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
              <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">let</span> get_n_users dbh user_ids <span class="doc_src_Sym">=</span></code>
<code class="doc_src_line">    <span class="doc_src_Kwd">match</span> user_ids <span class="doc_src_Kwd">with</span></code>
<code class="doc_src_line">    <span class="doc_src_Sym">|</span> <span class="doc_src_Sym">[]</span>    <span class="doc_src_Sym">-&gt;</span> <span class="doc_src_Sym">[]</span></code>
<code class="doc_src_line">    <span class="doc_src_Sym">|</span> _     <span class="doc_src_Sym">-&gt;</span> <span class="doc_src_Type">PGSQL</span><span class="doc_src_Sym">(</span>dbh<span class="doc_src_Sym">)</span> <span class="doc_src_Str">&quot;SELECT id, name, age FROM users WHERE id IN $@user_ids&quot;</span></code>

<code class="doc_src_line doc_src_dummy"></code></pre>
            </div>
            <div class="doc_caption doc_caption_long">
              <div class="doc_caption_aux">
                <h1 class="doc_caption_head">Print.&nbsp;7:
                </h1>
                <p class="doc_caption_body">A revised version of the function <tt class="doc_code">get_n_users</tt>. Unfortunately, the <span class="doc_caps">sql</span> standard does not accept empty list expressions. Therefore, when using the <tt class="doc_code">$@</tt> notation to programatically insert a list expression into a statement, the user is strongly advised to check against the empty case to avoid a runtime exception.
                </p>
              </div>
            </div>
          </div>
        </li>
        <li class="doc_item">
          <p class="doc_par">Particularly in older versions of <span class="doc_caps">postgresql</span> (before the 8.x series), large list expressions could cause serious performance and/or crashes in the database server <span class="doc_cite">[<a class="doc_lnk" href="#doc:u:bib:listoops">6</a>]</span>. You are therefore advised to upgrade to newer versions of <span class="doc_caps">postgresql</span> or to be careful with the size of the list expressions used programatically.
          </p>
        </li>
        <li class="doc_item">
          <p class="doc_par">Due to the way <span class="doc_caps">postgresql</span> prepared statements work, <span class="doc_caps">pg'ocaml</span> is forced to make a prepared statement for each length of a programatic list expression used. Therefore, if we were to invoke function <tt class="doc_code">get_n_users</tt> successively with lists <tt class="doc_code">[10_l]</tt>, <tt class="doc_code">[10_l; 11_l]</tt>, and <tt class="doc_code">[10_l; 11_l; 12_l]</tt>, <span class="doc_caps">pg'ocaml</span> would have to prepare and store each of the following statements:
          </p>
          <div class="doc_src_box doc_src_zebra doc_src_main">
            <pre class="doc_src_nums">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line">1</code>
<code class="doc_src_line">2</code>
<code class="doc_src_line">3</code>

<code class="doc_src_line doc_src_dummy"></code></pre>
            <pre class="doc_src_code">

<code class="doc_src_line doc_src_dummy"></code>
<code class="doc_src_line"><span class="doc_src_Kwd">SELECT</span> id<span class="doc_src_Sym">,</span> name<span class="doc_src_Sym">,</span> age <span class="doc_src_Kwd">FROM</span> users <span class="doc_src_Kwd">WHERE</span> id <span class="doc_src_Kwd">IN</span> <span class="doc_src_Sym">(</span>$<span class="doc_src_Num">1</span><span class="doc_src_Sym">)</span></code>
<code class="doc_src_line"><span class="doc_src_Kwd">SELECT</span> id<span class="doc_src_Sym">,</span> name<span class="doc_src_Sym">,</span> age <span class="doc_src_Kwd">FROM</span> users <span class="doc_src_Kwd">WHERE</span> id <span class="doc_src_Kwd">IN</span> <span class="doc_src_Sym">(</span>$<span class="doc_src_Num">1</span><span class="doc_src_Sym">,</span> $<span class="doc_src_Num">2</span><span class="doc_src_Sym">)</span></code>
<code class="doc_src_line"><span class="doc_src_Kwd">SELECT</span> id<span class="doc_src_Sym">,</span> name<span class="doc_src_Sym">,</span> age <span class="doc_src_Kwd">FROM</span> users <span class="doc_src_Kwd">WHERE</span> id <span class="doc_src_Kwd">IN</span> <span class="doc_src_Sym">(</span>$<span class="doc_src_Num">1</span><span class="doc_src_Sym">,</span> $<span class="doc_src_Num">2</span><span class="doc_src_Sym">,</span> $<span class="doc_src_Num">3</span><span class="doc_src_Sym">)</span></code>

<code class="doc_src_line doc_src_dummy"></code></pre>
          </div>
          <p class="doc_par">The astute observer will have noticed that if the size of the list is potentially very large, and if successive invocations of the function happen for varying sizes of the list, then the amount of memory spent on the prepared statements can easily grow out of hand. There is no easy workaround this issue, so the user should keep this problem in mind.
          </p>
        </li>
      </ol>
      <h1 id="doc:a:6" class="doc_sec"><span class="doc_order">6</span><span>Frequently Asked Questions</span>
      </h1>
      <h2 id="doc:a:7" class="doc_sec"><span class="doc_order">6.1</span><span>Are there provisions against <span class="doc_caps">sql</span> injections?</span>
      </h2>
      <p class="doc_par">Yes. Internally, <span class="doc_caps">pg'ocaml</span> uses so-called <i class="doc_emph">prepared statements</i> to operate on the database. What this means is that a statement is first prepared with placeholders instead of the actual parameters. The database then parses and creates a plan for the statement. It is only after this that the actual parameters are fed to the database. Not only does this procedure prevent the user to inject <span class="doc_caps">sql</span> statements, but it also saves the database engine the effort of parsing and planning the same statement each time it is issued.
      </p>
      <h2 id="doc:a:8" class="doc_sec"><span class="doc_order">6.2</span><span>Can I dynamically construct <span class="doc_caps">sql</span> statements?</span>
      </h2>
      <p class="doc_par">No. Bear in mind that <span class="doc_caps">pg'ocaml</span> must have access to the statement at compile-time. Therefore, you cannot build a statement dynamically from smaller pieces.
      </p>
      <h2 id="doc:a:9" class="doc_sec"><span class="doc_order">6.3</span><span>Can <tt class="doc_code">select</tt> statements return a list of records instead of tuples?</span>
      </h2>
      <p class="doc_par">This is not possible at the moment. If you need to convert the list of tuples returned by a <span class="doc_caps">pg'ocaml</span> statement, you need to run <tt class="doc_code">List.map</tt> on the returned list, and use a constructor function to convert a tuple into a record.
      </p>
      <h2 id="doc:a:10" class="doc_sec"><span class="doc_order">6.4</span><span>Is <span class="doc_caps">pg'ocaml</span> thread-safe?</span>
      </h2>
      <p class="doc_par">Yes, with some reservations. Internally, each database connection handle (the type returned by the function <tt class="doc_code">PGOCaml.connect</tt>) is a hash table produced by the module <tt class="doc_code">Hashtbl</tt>. This hash table contains the MD5 hashes of the <span class="doc_caps">sql</span> prepared statements, which are used to uniquely identify each prepared statement with the database server. Now, if two threads are simultaneously executing the same statement, and they both discover it is not in the hash table, then they will both compute its MD5 hash and use it to store the prepared statement in the database. The problem is that <span class="doc_caps">postgresql</span> cannot accept two prepared statements with the same identifier for the same connection, and will complain. Therefore, if you intend to use <span class="doc_caps">pg'ocaml</span> in a threaded programme, make sure that each thread uses a separate connection handler.
      </p>
      <h1 id="doc:a:11" class="doc_sec"><span>Acknowledgements</span>
      </h1>
      <p class="doc_par">I would like to thank Richard W. M. Jones, the author of <span class="doc_caps">pg'ocaml</span>, for reviewing the early drafts of this document and for answering all my doubts concerning the library.
      </p>
      <h1 id="doc:a:12" class="doc_sec"><span>Bibliography</span>
      </h1>
      <ol class="doc_bibs">
        <li id="doc:u:bib:pgocaml" class="doc_bib"><span class="doc_bib_head">[1]</span>
          <p class="doc_bib_body"><span class="doc_bib_author">a</span><span class="doc_bib_title">a</span><span class="doc_bib_resource"><a class="doc_lnk" href="http://merjis.com/developers/pgocaml">http://merjis.com/developers/pgocaml</a></span>
          </p>
        </li>
        <li id="doc:u:bib:postgresql" class="doc_bib"><span class="doc_bib_head">[2]</span>
          <p class="doc_bib_body"><span class="doc_bib_author">a</span><span class="doc_bib_title">a</span><span class="doc_bib_resource"><a class="doc_lnk" href="http://www.postgresql.org/">http://www.postgresql.org/</a></span>
          </p>
        </li>
        <li id="doc:u:bib:ocaml" class="doc_bib"><span class="doc_bib_head">[3]</span>
          <p class="doc_bib_body"><span class="doc_bib_author">a</span><span class="doc_bib_title">a</span><span class="doc_bib_resource"><a class="doc_lnk" href="http://caml.inria.fr/">http://caml.inria.fr/</a></span>
          </p>
        </li>
        <li id="doc:u:bib:camlp4" class="doc_bib"><span class="doc_bib_head">[4]</span>
          <p class="doc_bib_body"><span class="doc_bib_author">a</span><span class="doc_bib_title">a</span><span class="doc_bib_resource"><a class="doc_lnk" href="http://caml.inria.fr/pub/old_caml_site/camlp4/index.html">http://caml.inria.fr/pub/old_caml_site/camlp4/index.html</a></span>
          </p>
        </li>
        <li id="doc:u:bib:calendar" class="doc_bib"><span class="doc_bib_head">[5]</span>
          <p class="doc_bib_body"><span class="doc_bib_author">a</span><span class="doc_bib_title">a</span><span class="doc_bib_resource"><a class="doc_lnk" href="http://www.lri.fr/~signoles/prog.en.html">http://www.lri.fr/~signoles/prog.en.html</a></span>
          </p>
        </li>
        <li id="doc:u:bib:listoops" class="doc_bib"><span class="doc_bib_head">[6]</span>
          <p class="doc_bib_body"><span class="doc_bib_author">a</span><span class="doc_bib_title">a</span><span class="doc_bib_resource"><a class="doc_lnk" href="http://svr5.postgresql.org/pgsql-sql/2007-02/msg00251.php">http://svr5.postgresql.org/pgsql-sql/2007-02/msg00251.php</a></span>
          </p>
        </li>
      </ol>
      <h1 id="doc:a:13" class="doc_sec"><span>Notes</span>
      </h1>
      <ol class="doc_notes">
        <li id="doc:u:note:license" class="doc_note"><span class="doc_note_head">(1)</span>
          <div class="doc_note_body">
            <p class="doc_par">This work is licensed under a <a class="doc_lnk" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0 License</a>. The latest version of this document can always be found at the following address: <a class="doc_lnk" href="http://dario.dse.nl/projects/pgoctut/">http://dario.dse.nl/projects/pgoctut/</a> 
            </p>
          </div>
        </li>
        <li id="doc:u:nt:postmaster" class="doc_note"><span class="doc_note_head">(2)</span>
          <div class="doc_note_body">
            <p class="doc_par">The <i class="doc_emph">Postmaster</i> is the frontend process that manages connections to <span class="doc_caps">postgresql</span> databases. 
            </p>
          </div>
        </li>
        <li id="doc:u:nt:rows" class="doc_note"><span class="doc_note_head">(3)</span>
          <div class="doc_note_body">
            <p class="doc_par">In fact, there is no limit to the number of rows that a <span class="doc_caps">postgresql</span> database can hold. It just so happens that <tt class="doc_code">int64</tt> is the largest integer type that <span class="doc_caps">ocaml</span> can handle. 
            </p>
          </div>
        </li>
      </ol>
    </div>
  </body>
</html>
